---
updated: 2023-01-17
created: 2023-01-17
title: sql优化
categories: mysql
tags:
  - mysql

excerpt: ''

cover: https://ts1.cn.mm.bing.net/th/id/R-C.60361064d8eee12aa647695bf666bb38?rik=W663M7lXL03Y9A&riu=http%3a%2f%2fimg.mm4000.com%2ffile%2fe%2fe3%2f395f367325.jpg&ehk=mVwYGg59wm0g3RzSDpFZgv6EYwrdQQKlvIAtvNQsVTE%3d&risl=&pid=ImgRaw&r=0

---

#### 非聚簇索引和聚簇索引有什么区别？

在mysql默认引擎InnoDB中，索引大致可以分为两类，聚簇索引和非聚簇索引

> InnoDB中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引

##### 聚簇索引

聚簇索引一般指的是主键索引，聚簇索引也被称之为聚集索引。

聚簇索引在InnoDB中是使用B+树实现的，其叶子节点直接存储用户信息的内存地址，我们使用内存地址可以直接找到相应的行数据，每张表只能有一个聚簇索引。

##### 非聚簇索引

非聚簇索引在InnoDB引擎中也叫二级索引。在非聚簇索引的叶子节点上存储的并不是真正的行数据，而是主键ID，所以当我们使用非聚簇索引进行查询时，首先会得到一个主键ID，然后再使用主键ID去聚簇索引上找到真正的行数据，这个过程叫做回表查询。

#### SQL优化

##### 避免使用select *

使用select *一次查出所有的列，往往只需要其中一两列，白白浪费cpu或者内存资源，多查出的数据在网络传输过程中，也会增加数据传输时间

select *不会走覆盖索引，会出现大量回表操作，从而导致查询sql的性能很低。

##### 使用union all代替union

在使用union时，会对查出的数据进行去重，去重过程中需要遍历表，更耗时更消耗cpu资源

##### 小表驱动大表

~~~sql
--exists先查外部表,外部是小表
select * from t_admin where exists (select 1 from test2 where t_admin.uid=test2.id);

--in先查内部表，内部是小表
select * from t_admin where t_admin.uid IN (select id from test2);
~~~

##### 批量操作

一次新增多条数据时，如果一条一条插入，每次连接数据库都会耗费性能，增加查询时间，可以提供一个批量插入方法，如mp中insertBatch(list)方法

##### 多用limit

比如要查询一个用户订单第一条数据时，可以把用户订单全部查询出来，然后再get(0)，这种做法非常浪费资源。

可以在查询时候使用limit 1进行获取数据

##### in中值太多

##### 增量查询

##### 高效的分页

##### 用连接查询代替子查询

使用in子查询时，会先将in里面查询出来的数据构建一个临时表，查询完再删掉，此时可以用join连接查询替代子查询

##### join的表不宜过多

join连接查询时，一般不要超过3张

##### join时要注意

使用inner join时，会自动选择小表驱动大表

在使用left join时，是使用左边表驱动右边表，一般左边表设置成小表

##### 控制索引的数量

索引能够显著提升查询sql的性能，但索引并非越多越好，当insert数据时，会为他创建索引，而索引是需要额外存储空间的。在insert，update，delete时需要更新B+树索引，如果索引过多，会消耗很多额外的性能。

##### 选择合理的字段类型

比如当长度固定时，如手机号11位，就可以用char(11)存储

如长度不固定，使用char存固定长度数据浪费空间，可以使用varchar类型，根据实际长度存储。

##### 提升group by效率

分组是一个相对耗时的操作，可以先where过滤数据，再进行分组。

##### 索引优化

###### InnoDB和MyISAM区别

InnoDB是行锁，操作时候只锁一行数据，适合高并发;MyISAM是表锁

InnoDB不仅缓存索引还缓存真实数据，MyISAM只缓存索引

InnoDB需要表空间大，

InnoDB关注事务，MyISAM关注性能(查)

###### 使用join时注意

比如left join 一定是左表小表，右表大表，小表驱动大表

在右表加索引，因为左表一定是全部查询的，性能主要在右表。

###### 不满足最左前缀原则

如果索引了多列(复合索引)，查询从索引的最左前列开始，且不能跳过索引中间的列。

###### 范围索引没有放最后

复合索引(a,b,c)当b使用了范围查找，查寻数据包含c时索引失效

###### 使用了select *

尽量使用覆盖索引，只访问索引的查询(索引列和查询列一致)，避免回表查询，减少select *

###### 索引列上有计算

###### 索引列上使用了函数

###### 字符类型没加引号(造成数据强转)

###### 用is null和is not null没注意字段是否允许为空

###### like查询左边有%

###### 使用or关键字没有注意

用or来连接时候会索引失效

